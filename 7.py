def challenge49():
  pass
  
def challenge50():
  pass
  
def challenge51():
  pass
  
def challenge52():
  pass
  
def challenge53():
  pass
  
def challenge54():
  pass
  
def challenge55():
  m1 = [0x4d7a9c83, 0x56cb927a, 0xb9d5a578, 0x57a7a5ee, 0xde748a3c, 0xdcc366b3, 0xb683a020, 0x3b2a5d9f, 0xc69d71b3, 0xf9e99198, 0xd79f805e, 0xa63bb2e8, 0x45dd8e31, 0x97e31fe5, 0x2794bf08, 0xb9e8c3e9]
  m1 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in m1] for item in sublist])
  m1prime = [0x4d7a9c83, 0xd6cb927a, 0x29d5a578, 0x57a7a5ee, 0xde748a3c, 0xdcc366b3, 0xb683a020, 0x3b2a5d9f, 0xc69d71b3, 0xf9e99198, 0xd79f805e, 0xa63bb2e8, 0x45dc8e31, 0x97e31fe5, 0x2794bf08, 0xb9e8c3e9]
  m1prime = bytes([item for sublist in [y.to_bytes(4, 'little') for y in m1prime] for item in sublist])
  m2 = [0x4d7a9c83, 0x56cb927a, 0xb9d5a578, 0x57a7a5ee, 0xde748a3c, 0xdcc366b3, 0xb683a020, 0x3b2a5d9f, 0xc69d71b3, 0xf9e99198, 0xd79f805e, 0xa63bb2e8, 0x45dd8e31, 0x97e31fe5, 0xf713c240, 0xa7b8cf69]
  m2 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in m2] for item in sublist])
  m2prime = [0x4d7a9c83, 0xd6cb927a, 0x29d5a578, 0x57a7a5ee, 0xde748a3c, 0xdcc366b3, 0xb683a020, 0x3b2a5d9f, 0xc69d71b3, 0xf9e99198, 0xd79f805e, 0xa63bb2e8, 0x45dc8e31, 0x97e31fe5, 0xf713c240, 0xa7b8cf69]
  m2prime = bytes([item for sublist in [y.to_bytes(4, 'little') for y in m2prime] for item in sublist])
  h1 = [0x5f5c1a0d, 0x71b36046, 0x1b5435da, 0x9b0d807a]
  h1 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in h1] for item in sublist])
  hstar1 = [0x4d7e6a1d, 0xefa93d2d, 0xde05b45d, 0x864c429b]
  hstar1 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in hstar1] for item in sublist])
  h2 = [0xe0f76122, 0xc429c56c, 0xebb5e256, 0xb809793]
  h2 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in h2] for item in sublist])
  hstar2 = [0xc6f3b3fe, 0x1f4833e0, 0x697340fb, 0x214fb9ea]
  hstar2 = bytes([item for sublist in [y.to_bytes(4, 'little') for y in hstar2] for item in sublist])
  md4 = MD4()
  md4._dontPad = True #unpadded little-endian
  #without multi-step modification, the probability is 2^-25
  if (MD4.applyWangDifferential(m1) != m1prime): return False
  if (md4.computeHash(m1) != md4.computeHash(m1prime)): return False
  if (md4.computeHash(m1) != h1): return False
  if (MD4.applyWangDifferential(m2) != m2prime): return False
  if (md4.computeHash(m2) != md4.computeHash(m2prime)): return False
  if (md4.computeHash(m2) != h2): return False
  md4._dontPad = False
  md4._bigEndian = True
  if (md4.computeHash(m1) != hstar1): return False #padded big-endian
  if (md4.computeHash(m1prime) != hstar1): return False
  if (md4.computeHash(m2) != hstar2): return False
  if (md4.computeHash(m2prime) != hstar2): return False
  mRandom = codecs.decode("24ce9d37de4dfca0a3b88fc39c9f9e5c92ee86ada2c9e8b088f3a020c5368a690e503cc80c2368f978ff57bf21a1762ad018afb8daa431e9308bf382806a18a1", "hex")
  mRandom = bytes([item for sublist in [[mRandom[i  + 3], mRandom[i + 2], mRandom[i + 1], mRandom[i]] for i in range(0, len(mRandom), 4)] for item in sublist])  
  m1Naito = codecs.decode("368b9d377e2dfc60b5b88fcb0c8fbe5601a6662d9ecc3929aa35aabf887f929f2740a2c8c8c12039bbb401bdc1983331e45e1f61c150d565ee27d04af1dfec4c", "hex")
  m1Naito = bytes([item for sublist in [[m1Naito[i + 3], m1Naito[i + 2], m1Naito[i + 1], m1Naito[i]] for i in range(0, len(m1Naito), 4)] for item in sublist])  
  m1primeNaito = codecs.decode("368b9d37fe2dfc6025b88fcb0c8fbe5601a6662d9ecc3929aa35aabf887f929f2740a2c8c8c12039bbb401bdc1983331e45d1f61c150d565ee27d04af1dfec4c", "hex")
  m1primeNaito = bytes([item for sublist in [[m1primeNaito[i + 3], m1primeNaito[i + 2], m1primeNaito[i + 1], m1primeNaito[i]] for i in range(0, len(m1primeNaito), 4)] for item in sublist])  
  hNaito = bytes(reversed(codecs.decode("".join(list(reversed("26a280327c3068532de33b679d022e59"))), "hex")))
  hNaito = bytes([item for sublist in [[hNaito[i + 3], hNaito[i + 2], hNaito[i + 1], hNaito[i]] for i in range(0, len(hNaito), 4)] for item in sublist])  
  if (MD4.applyWangDifferential(m1Naito) != m1primeNaito): return False
  md4._dontPad = True
  if (md4.computeHash(m1Naito) != hNaito): return False
  key = bytearray(64)
  total = 0
  md4._bigEndian = False
  for i in range(50000):
    n = 0
    while True:
      n += 1
      key = random.getrandbits(64 * 8).to_bytes(64, 'little')
      save = key[:]
      check = MD4.wangsAttack(key, True, False)
      if (not check is None): key = check
      forgery = MD4.applyWangDifferential(key) if (not check is None) else None
      #if (not check is None and (md4.computeHash(key) != md4.computeHash(forgery))):
      if not (check is None or (md4.computeHash(key) != md4.computeHash(forgery))): break
    #correct algorithm will have n == 2^2 = 4 up to n == 2^6 = 64 average tries
    #Naito exactly computed this as 1/(3/4*7/8*1/2*(1/2)^2*(1/2)^2) which yields 48.76 average tries, but he did not consider Wang's m[14] and m[15] round 3 search strategy
    #therefore truly this should be 1/(3/4*7/8*1/2*(1/2)^2) which yields 12.19 average tries
    #since we search out the missing conditions, and the 7/8 seems to be 1 and the Naito has no explanation
    #if only one round of Wang's attack probability matches 1/(3/4*1/2*1/16)=42.6666
    #1/(1/(1-1/8)-1)=7 is expected number of rounds if probability 1/8 per round...
    #1/(3/4*1/2)*7=18.666
    #print("Wang et al. paper attack: " + str(n) + " tries " + key.hex() + " " + forgery.hex() + " -> " + md4.computeHash(key).hex())
    total += n
  print("Wang et al. paper attack: " + str(total) + " tries to find 50000 collisions with probability " + str(total / 50000))
  total = 0
  for i in range(5000):
    n = 0
    while True:
      n += 1
      key = random.getrandbits(64 * 8).to_bytes(64, 'little')
      key = MD4.wangsAttack(key, True, True)
      forgery = MD4.applyWangDifferential(key)
      #if ((md4.computeHash(key) != md4.computeHash(forgery))):
      if not md4.computeHash(key) != md4.computeHash(forgery): break
    #correct algorithm will have n == 1 almost always precisely 1-(1-1/4)^(2^19)=per Wolfram Alpha 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
    #print("Naito et al. improvement: " + str(n) + " tries " + key.hex() + " " + forgery.hex() + " -> " + md4.computeHash(key).hex())
    total += n
  print("Naito et al. improvement: " + str(total) + " tries to find 5000 collisions with probability " + str(total / 5000))
  return total == 5000
  
def challenge56():
  pass